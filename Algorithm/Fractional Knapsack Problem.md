# 배낭 (Knapsack) 문제

n개의 물건이 각각 1개씩 있고, 각 물건은 무게와 가치를 갖고 있으며 배낭이 한정된 무게의 물건들을 담을 수 있을 때 최대의 가치를 갖도록 배낭에 넣을 물건들을 정하는 문제

- **부분 배낭(Fractional Knapsack) 문제**
    - 물건을 부분적으로 담는 것을 허용하며, 그리디 알고리즘으로 해결
    - 최적해를 위해 ‘욕심 내어’ 단위 무게당 가장 값나가는 물건을 배낭에 넣고 계속해서 그 다음으로 값나가는 물건을 넣는다
    - 만일 그 다음으로 값나가는 물건을 ‘통째로’ 배낭에 넣을 수 없게 되면 배낭에 넣을 수 있을 만큼만 물건을 부분적으로 넣는다 (물건이 ‘분말’이라고 생각)
- **0-1 배낭 문제**
    - 부분 배낭 문제의 원형으로, 물건을 통째로 배낭에 넣어야 한다. 동적 계획 알고리즘, 백트래킹 기법, 분기 한정 기법으로 해결 가능

<br>
<br>

**Pseudo-Code**

```c
FractionalKnapsack():
Input : n개의 물건과 각 물건의 무게와 가치, 배낭의 용량 C
Output : 배낭에 담은 물건 리스트 L과 배낭에 담은 물건의 가치 합 V

각 물건의 단위 무게당 가치 계산
물건들의 단위 무게당 가치를 기준으로 내림차순 정렬하고, 정렬된 물건 리스트를 S라고 하자

L = ∅, w = 0, v = 0
// L : 배낭에 담을 물건 리스트, w : 배낭에 담긴 물건 무게의 합, v : 배낭에 담긴 물건 가치의 합

S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다
while ((w+x의 무게) <= C) {
	x를 L에 추가
	w = w + x의 무게
	v = v + x의 가치
	x를 S에서 제거
	S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다
}

if ((C-w) > 0) {
	물건 x를 (C-w)만큼만 L에 추가
	v = v + (C-w)만큼의 x의 가치
}

return L, v
```

<br>
<br>

**시간복잡도**

- n개의 물건 각각의 단위 무게당 가치 계산 : O(n)
- 물건들의 단위 무게당 가치에 대해 내림차순 정렬 : O(nlogn)
- while-loop n번 수행, 루프 내부 수행 O(1), If문 O(1)

→ O(n) + O(nlogn) + n * O(1) + O(1) = O(nlogn)

<br>
<br>


**0-1 배낭 문제**

- 부분 배낭 문제와 전체적인 컨셉은 유사하지만 0-1 배낭 문제는 물건을 부분적으로 넣을 수 없다
- ‘0’ : 물건을 배낭에 안넣는 것, ‘1’ : 물건을 배낭에 넣는 것
- 그리디 알고리즘으로 해결이 불가능하며, 동적계획 알고리즘, 백트래킹 기법, 분기 한정 기법 등을 통해 해결할 수 있다.
- 최소의 비용으로 자원을 할당하는 문제

<br>
<br>

**Application**

- 조합론, 계산이론, 암호학, 응용 수학 분야에서 기본적인 문제로 다뤄짐
- ‘버리는 부분을 최소화시키는’ 원자재 자르기 (Raw Material Cutting)
- 자산 투자 및 금융 포트폴리오 (Financial Portfolio)
- Merkle-Hellman 배낭 암호 시스템에 사용

<br>
<br>

## Reference
- [알기 쉬운 알고리즘 (양성봉 지음)](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=&barcode=9788970504896)
