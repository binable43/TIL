# 허프만 압축 (Huffman Coding)

파일의 각 문자가 8bit ASCII 코드로 저장되면 그 파일의 bit 수는 8 * (파일의 문자 수)와 같다. 

파일의 각 문자는 일반적으로 고정된 크기의 코드로 표현되는데, 이를 저장하거나 전송할 때 파일 크기를 줄이고 필요할 때 원래의 파일로 변환할 수 있으면 메모리 공간을 효율적으로 사용 가능하며 파일 전송 시간도 단축할 수 있다. 파일의 크기를 줄이는 방법을 **파일 압축 (File Compression)** 이라고 한다.

<br>

**허프만(Huffman) 압축**은 파일에 빈번하게 나타나는 문자에는 짧은 이진 코드를 할당하고, 드물게 나타나는 문자에는 긴 이진 코드를 할당한다. 허프만 압축 방법으로 변환시킨 문자 코드들 사이에는 접두부 특성(prefix property)이 존재한다. 접두부 특성은 코드와 코드 사이를 구분할 특별한 코드(ex. #)가 필요 없다.

허프만 압축은 입력 파일에 대하여 각 문자의 빈도 수에 기반을 둔 이진 트리를 만들어서 각 문자에 이진 코드를 할당하며, 이러한 이진 코드를 **허프만 코드**라고 한다.

<br>
<br>

**Pseudo-Code**

```c
HuffmanCoding():
Input : 입력 파일의 n개의 문자에 대한 각각의 빈도 수
Output : 허프만 트리

각 문자 당 노드를 만들고, 그 문자의 빈도 수를 노드에 저장
n 노드의 빈도수에 대해 우선 순위 큐 Q를 만든다

while (Q에 있는 노드 수 >= 2) {
		빈도 수가 가장 적은 2개의 노드 (A와 B)에서 Q를 제거
		새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다
		N의 빈도 수 = A의 빈도 수 + B의 빈도 수
		노드 N을 Q에 삽입
}

// 허프만 트리의 루트를 리턴
return Q
```

<br>
<br>


**시간복잡도**

- n개의 노드를 만들고 각 빈도수를 노드에 저장 : O(n)
- n개의 노드로 우선순위 큐 Q를 만든다 : O(n)
- 최소 빈도수를 가진 노드 2개를 Q에서 제거하는 힙 삭제 연산과 새 노드를 Q에 삽입하는 연산 O(logn), while-loop (n-1)번 반복 → (n-1) * O(logn) = O(nlogn)
- 트리 루트 반환하는 시간 : O(1)

→ O(n) + O(n) + O(nlogn) + O(1) = O(nlogn)

<br>
<br>

**Application**

- 팩스(FAX), 대용량 데이터 저장, 멀티미디어, MP3 압축 등
- 정보 이론(Information Theory) 분야에서 엔트로피 계산 (자료의 불특정성 분석 및 예측)

<br>
<br>

## Reference
- [알기 쉬운 알고리즘 (양성봉 지음)](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=&barcode=9788970504896)
