# 최소 신장 트리 (Minimum Spanning Tree)

주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시킨 트리들 중 간선들의 가중치 합이 최소인 트리

![1](https://user-images.githubusercontent.com/81629116/163942352-2845d602-2a34-4f97-ac92-351e504773d2.png)


위와 같이 가중치 그래프가 주어졌을 때 최소 신장 트리는 무엇일까?
![2](https://user-images.githubusercontent.com/81629116/163942394-da3c1f86-d0c7-47a3-b604-c7e589c24141.png)



첫 번째 트리는 최소 신장 트리다. 두 번째 트리는 가중치의 합이 첫 번째보다 크기 때문에 최소 신장 트리가 아니다. 세 번째 트리는 모든 노드를 포함하고 있지 않기 때문에 최소 신장 트리가 아니다.

<br>
<br>

**최소 신장 트리 찾는 방법**

- 사이클이 없도록 모든 점을 연결시킨다
- 그래프 점의 수가 n일 때 신장 트리에는 (n-1)개의 간선이 있다. 여기서 트리에 간선을 하나 추가시키면 반드시 사이클이 만들어진다

![3](https://user-images.githubusercontent.com/81629116/163942450-4d4344ec-2033-44df-a86e-e99eb3772bce.png)


- 대표적인 2가지 그리디 알고리즘
    - 크러스컬(Kruskal) 알고리즘
    - 프림(Prim) 알고리즘
<br>
<br>

## 크러스컬(Kruskal) 알고리즘

가중치가 가장 작은 간선이 사이클을 만들지 않을 때에만 ‘욕심 내어' 그 간선을 추가시킨다

<br>

**Pseudo-Code**

```c
KruskalMST(G):
Input : 가중치 그래프 G=(V,E), |V|=n, |E|=m
Output : 최소 신장 트리 T

가중치의 오름차순으로 간선들을 정렬 : L = 정렬된 간선 리스트
T = ∅   // 트리 T를 초기화

while (T의 간선 수 < n-1) :
	L에서 가장 작은 가중치를 가진 간선 e를 가져오고, L에서 e 제거
	if (간선 e가 T에 추가되어 사이클을 만들지 않으면)
		e를 T에 추가  
	else     // e가 T에 추가되어 사이클이 생기는 경우
		e를 버린다
return 트리 T   // T는 최소 신장 트리
```

- 트리를 초기화 → 트리 T에는 아무 간선도 없는 상태에서 while문이 실행
- L은 모든 노드들을 연결했을 때 만들어지는 간선들을 정렬한 리스트이다.
- L에서 가중치가 가장 작은 간선 e를 가져오고, 가져온 e는 L에서 삭제된다
- 이 때 가져온 간선 e를 트리 T에 추가했을 때 사이클을 만들면 e를 버리고, 사이클을 만들지 않으면 e를 T에 추가한다 → 최소 신장 트리 T는 간선들이 사이클을 만들지 않는 트리이기 때문!
- 항상 L에서 ‘욕심 내어’ 작은 가중치를 가진 간선을 가져오기 때문에 그리디 알고리즘이다.

<br>
<br>

**KruskalMST 알고리즘의 시간복잡도**

- 간선들을 리스트 L에서 가중치로 정렬하는 데 걸리는 시간 : O(mlogm)
- 트리 T를 단순히 초기화 하는 데 걸리는 시간 : O(1)
- 최악의 경우 while-loop가 실행되는 횟수 : m
- while-loop에서 L로부터 가져온 간선 e가 사이클을 만드는 지 검사하는 시간 : O(log*m)
- O(mlogm) + O(mlog*m) = O(mlogm)

<br>
<br>

## 프림(Prim) 알고리즘

주어진 가중치 그래프에서 임의의 점 하나를 선택한 다음, (n-1)개의 간선을 하나씩 추가시켜서 트리를 만든다. 추가되는 간선은 현재까지 만들어진 트리에 연결시킬 때 ‘욕심 내어’ 항상 최소의 가중치로 연결되는 간선이다.

**Pseudo-Code**

```c
PrimMST(G):
Input : 가중치 그래프 G=(V,E), |V|=n, |E|=m
Output : 최소 신장 트리 T

G에서 임의의 점 p를 시작점으로 선택 D[p]= 0
	// D[v]는 T에 있는 u와 v를 연결하는 간선의 최소 가중치를 저장하기 위한 원소

for (점 p가 아닌 각 점 v에 대하여) {    // 배열 D의 초기화
	if (간선(p,v)가 그래프에 있으면)
		D[v] = 간선 (p, v)의 가중치
	else
		D[v] = ∞
}

// 초기에 트리 T는 점 p만을 가진다
T = {p}

while (T에 있는 점의 수 < n) {
	T에 속하지 않은 각 점 v에 대하여 D[v]가 최소인 점 v_min과 연결된 간선 (u, v_min)을 T에 추가
	여기서 u는 T에 속한 점이고 점 v_min도 T에 추가

	for (T에 속하지 않은 각 점 w에 대해서) {
		if (간선 (v_min, w)의 가중치 < D[w])
			D[w] = 간선 (v_min, w)의 가중치    // D[w]를 갱신
	}
}

return T    //T는 최소 신장 트리
```

- 임의로 점 p를 선택하고 D[p] = 0 으로 둔다
- D[v]에는 점 v와 T의 점들을 연결하는 간선들 중 최소 가중치를 가진 간선들의 가중치를 저장
- 시작점 c와 간선으로 연결된 각 점 v에 대하여, D[v]를 각 간선의 가중치로 초기화
- 나머지 각 점 v에 대하여, D[v]는 ∞으로 초기화
- 초기에 Tree T는 점을 p만 가진다 → T = {p} 로 초기화
- T에 가장 가까운 점 b를 추가
- 항상 T 밖에 있는 점을 추가하기 때문에 프림 알고리즘은 사이클을 만들지 않는다.

<br>

**시간복잡도**

- while-loop (n-1)번 반복
    - 1회 반복될 때마다 T에 속하지 않은 각 점 v에 대하여 D[v]가 최소인 점을 찾는데 O(n) 소요

→ (n-1) * O(n) = O(n^2)

<br>
<br>

## Kruskal & Prim 알고리즘 비교

- Kruskal : n개의 트리들이 점차 합쳐져서 1개의 신장 트리가 만들어진다
- Prim : 1개의 트리가 자라나서 신장 트리가 된다

<br>

**Applications**

- 최소 비용으로 선로 또는 파이프 네트워크 설치
    - 인터넷 광케이블 선로, 케이블 TV 선로, 전화선로, 송유관로, 가스관로, 배수로 등
- 여행자 문제(Traveling Salesman Problem)를 근사적으로 해결하는 데 이용

<br>
<br>

## Reference
- [알기 쉬운 알고리즘 (양성봉 지음)](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=&barcode=9788970504896)
